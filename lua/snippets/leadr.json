{
   "Component w/ Hook Container - Commented":{
      "description":"Generates a component and hook container with introductory documentation to best practices",
      "prefix":"leadr-componentWithHook-commented",
      "body":[
         "/*",
         "  Let's talk imports.",
         "",
         "  For imports, we prefer the following format",
         "",
         "  -",
         "  import Thing from 'npm library'",
         "",
         "  import OtherThing from '~internal file path",
         "  -",
         "",
         "  We want libraries on top and project imports on the bottom with a space seperating them.",
         "  If you are unsure if there is a component that already exists, check in #frontend-guild. We want to be reusing as much as possible.",
         "*/",
         "",
         "import { css } from '@emotion/react';",
         "",
         "import { palette } from '~Common/styles/colors';",
         "",
         "/*",
         "  We use emotion to style our components. You can use the following resources to learn more about emotion below:",
         "  https://emotion.sh/docs/introduction",
         "  https://emotion.sh/docs/css-prop",
         "",
         "  The most important thing to understand with emotion is that the css prop is transformed into a classname.",
         "  If you don't either spread props or pass the classname down, then it will not propagate for custom components.",
         "",
         "  We have a lot of common data like colors, animations, fonts, etc inside of ~Common/styles so check there if you need anything.",
         "",
         "  Any questions, feel free to ask #frontend-guild on Slack.",
         "*/",
         "const styles = {",
         "  ${TM_FILENAME_BASE/(.*)/${1:/camelcase}/}: css({",
         "    backgroundColor: palette.neutrals.gray500,",
         "  }),",
         "};",
         "",
         "/*",
         "  The point of seperating these View components from the Hooks (seen below) is to create a kind of model-view pattern.",
         "  The goal is that props should contain everything this component needs to render. It shouldn't pull in anything",
         "  outside of major library imports unless it's from props.",
         "",
         "  It also should not compute anything, instantiate anything, etc. It should only pull from props and implement.",
         "",
         "  This is known as a pure component. The idea here is that a pure component is easier to test and more reusable.",
         "  This View will be exported from this file, and another hook can be made that reuses this View if the opportunity arises.",
         "",
         "  Any questions, feel free to ask #frontend-guild on Slack.",
         "*/",
         "",
         "/*",
         "  We use Typescript inside of our components. You can use the following link to learn more about Typescript:",
         "  https://www.typescriptlang.org/docs/",
         "*/",
         "interface ViewProps {",
         "",
         "}",
         "",
         "const View = ({ ...props }: ViewProps): JSX.Element => (",
         "  <div",
         "    css={styles.${TM_FILENAME_BASE/(.*)/${1:/camelcase}/}}",
         "    {...props}",
         "  >",
         "    The View!",
         "  </div>",
         ");",
         "",
         "/*",
         "  This is the hook container which wraps the View. The goal here is to compute all the data, use react-query hooks, etc and get all your data and functions",
         "  ready for the view. You can even define styles and such here if needed for branching components (rare but worth mentioning).",
         "",
         "  All computed props should be added to the hookProps object which will just spread them in, overwriting props if keynames overlap.",
         "",
         "  The reason we do the hookprops spread is mostly because destructuring makes it more convenient to add props to an object and spreading it in",
         "  rather than adding props to the component tag.",
         "",
         "  Any questions, feel free to ask #frontend-guild on Slack.",
         "*/",
         "",
         "/*",
         "  We use Typescript inside of our components. You can use the following link to learn more about Typescript:",
         "  https://www.typescriptlang.org/docs/",
         "*/",
         "interface ${TM_FILENAME_BASE}Props {",
         "",
         "}",
         "",
         "const ${TM_FILENAME_BASE} = ({ ...props }: ${TM_FILENAME_BASE}Props): JSX.Element => {",
         "  const hookProps = {};",
         "",
         "  return (",
         "    <View",
         "      {...hookProps}",
         "      {...props}",
         "    />",
         "  );",
         "};",
         "",
         "/*",
         "  We export both the View and the Hook. Since the Hook implements the View, we default export the hook and specificaly export the View for things",
         "  like tests and code reuse in the future if it's needed. For practical purposes, you will almost never import the View.",
         "",
         "  Any questions, feel free to ask #frontend-guild on Slack.",
         "*/",
         "export { View };",
         "export default ${TM_FILENAME_BASE};",
         ""
      ]
   },
   "Component w/ Hook Container":{
      "description":"Generates a component and hook container",
      "prefix":"leadr-componentWithHook",
      "body":[
         "import { css } from '@emotion/react';",
         "",
         "import { palette } from '~Common/styles/colors';",
         "",
         "const styles = {",
         "  ${TM_FILENAME_BASE/(.*)/${1:/camelcase}/}: css({",
         "    backgroundColor: palette.neutrals.gray500,",
         "  }),",
         "};",
         "",
         "interface ViewProps {",
         "",
         "}",
         "",
         "const View = ({ ...props }: ViewProps): JSX.Element => (",
         "  <div",
         "    css={styles.${TM_FILENAME_BASE/(.*)/${1:/camelcase}/}}",
         "    {...props}",
         "  >",
         "    The View!",
         "  </div>",
         ");",
         "",
         "interface ${TM_FILENAME_BASE}Props {",
         "",
         "}",
         "",
         "const ${TM_FILENAME_BASE} = ({ ...props }: ${TM_FILENAME_BASE}Props): JSX.Element => {",
         "  const hookProps = {};",
         "",
         "  return (",
         "    <View",
         "      {...hookProps}",
         "      {...props}",
         "    />",
         "  );",
         "};",
         "",
         "export { View };",
         "export default ${TM_FILENAME_BASE};",
         ""
      ]
   },
   "Pure Component - Commented":{
      "description":"Generates a pure component with introductory documentation to best practices",
      "prefix":"leadr-pureComponent-commented",
      "body":[
         "/*",
         "  Let's talk imports.",
         "",
         "  For imports, we prefer the following format",
         "",
         "  -",
         "  import Thing from 'npm library'",
         "",
         "  import OtherThing from '~internal file path",
         "  -",
         "",
         "  We want libraries on top and project imports on the bottom with a space seperating them.",
         "  If you are unsure if there is a component that already exists, check in #frontend-guild. We want to be reusing as much as possible.",
         "*/",
         "",
         "import { css } from '@emotion/react';",
         "",
         "import { palette } from '~Common/styles/colors';",
         "",
         "/*",
         "  We use emotion to style our components. You can use the following resources to learn more about emotion below:",
         "  https://emotion.sh/docs/introduction",
         "  https://emotion.sh/docs/css-prop",
         "",
         "  The most important thing to understand with emotion is that the css prop is transformed into a classname.",
         "  If you don't either spread props or pass the classname down, then it will not propagate for custom components.",
         "",
         "  We have a lot of common data like colors, animations, fonts, etc inside of ~Common/styles so check there if you need anything.",
         "",
         "  Any questions, feel free to ask #frontend-guild on Slack.",
         "*/",
         "const styles = {",
         "  ${TM_FILENAME_BASE/(.*)/${1:/camelcase}/}: css({",
         "    backgroundColor: palette.neutrals.gray500,",
         "  }),",
         "};",
         "",
         "/*",
         "  If you are creating a component without a hook, this should still follow the rules of a pure component.",
         "",
         "  It should not compute anything, instantiate anything, etc. It should only pull from props and implement.",
         "",
         "  This is known as a pure component. The idea here is that a pure component is easier to test and more reusable.",
         "  If you need to compute, instantiate, etc, then use the component-with-hook snippet instead.",
         "",
         "  Any questions, feel free to ask #frontend-guild on Slack.",
         "*/",
         "",
         "/*",
         "  We use Typescript inside of our components. You can use the following link to learn more about Typescript:",
         "  https://www.typescriptlang.org/docs/",
         "*/",
         "interface ${TM_FILENAME_BASE}Props {",
         "",
         "}",
         "",
         "const ${TM_FILENAME_BASE} = ({ ...props }: ${TM_FILENAME_BASE}Props): JSX.Element => (",
         "  <div",
         "    css={styles.${TM_FILENAME_BASE/(.*)/${1:/camelcase}/}}",
         "    {...props}",
         "  >",
         "    The ${TM_FILENAME_BASE}!",
         "  </div>",
         ");",
         "",
         "export default ${TM_FILENAME_BASE};",
         ""
      ]
   },
   "Pure Component":{
      "description":"Generates a pure component",
      "prefix":"leadr-pureComponent",
      "body":[
         "import { css } from '@emotion/react';",
         "",
         "import { palette } from '~Common/styles/colors';",
         "",
         "const styles = {",
         "  ${TM_FILENAME_BASE/(.*)/${1:/camelcase}/}: css({",
         "    backgroundColor: palette.neutrals.gray500,",
         "  }),",
         "};",
         "",
         "interface ${TM_FILENAME_BASE}Props {",
         "",
         "}",
         "",
         "const ${TM_FILENAME_BASE} = ({ ...props }: ${TM_FILENAME_BASE}Props): JSX.Element => (",
         "  <div",
         "    css={styles.${TM_FILENAME_BASE/(.*)/${1:/camelcase}/}}",
         "    {...props}",
         "  >",
         "    The ${TM_FILENAME_BASE}!",
         "  </div>",
         ");",
         "",
         "export default ${TM_FILENAME_BASE};",
         ""
      ]
   },
   "Drawer Component":{
      "description":"Generates a drawer component and hook container",
      "prefix":"leadr-drawerComponent",
      "body":[
         "import { css } from '@emotion/react';",
         "import { DRAWER_WIDTHS, DrawerProps } from '~Common/const/drawers';",
         "",
         "import { palette } from '~Common/styles/colors';",
         "import { registerDrawer, templateType } from '~Deprecated/ui/views/DrawerManager';",
         "",
         "const styles = {",
         "  ${1/(.*)/${1:/camelcase}/}: css({",
         "    backgroundColor: palette.neutrals.gray500,",
         "  }),",
         "};",
         "",
         "/*",
         "  All you have to do is type the name of the drawer in Proper case. Example: CreateMeetingDrawer",
         "  Then press Tab on your keyboard and the snippet will fill in all the variables with the right casing",
         "*/",
         "export const ${1/(.*)/${1:/camelcase}/}Template = {",
         "  name: '${1/([A-Z][a-z]+$)|((^|[A-Z])[a-z]+)/${1:/upcase}${2:/upcase}${2:+_}/gm}',",
         "  type: templateType.PRIMARY,",
         "  width: DRAWER_WIDTHS.PRIMARY,",
         "};",
         "",
         "interface ViewProps {",
         "",
         "}",
         "",
         "const View = ({ ...props }: ViewProps): JSX.Element => (",
         "  <div",
         "    css={styles.${1/(.*)/${1:/camelcase}/}}",
         "    {...props}",
         "  >",
         "    The View!",
         "  </div>",
         ");",
         "",
         "interface ${1:argName}Props extends DrawerProps<unknown> {",
         "",
         "}",
         "",
         "const ${1:argName} = ({ ...props }: ${1:argName}Props): JSX.Element => {",
         "  const hookProps = {};",
         "",
         "  return (",
         "    <View",
         "      {...hookProps}",
         "      {...props}",
         "    />",
         "  );",
         "};",
         "",
         "registerDrawer({",
         "  templateName: ${1/(.*)/${1:/camelcase}/}Template.name,",
         "  component: ${1:argName},",
         "});",
         "",
         "export { View };",
         "export default ${1:argName};",
         ""
      ]
   },
   "Hook Container - Commented":{
      "description":"Generates a hook container with introductory documentation",
      "prefix":"leadr-hookContainer-commented",
      "body":[
         "/*",
         "  Let's talk imports.",
         "",
         "  First, what the hell is this jsxImportSource? https://emotion.sh/docs/css-prop#jsx-pragma",
         "  Note that we are using CRA4 with React 17, so we are using the new JSX runtime.",
         "  This also means that you do not need to import React into a JSX file anymore.",
         "",
         "  For imports, we prefer the following format",
         "",
         "  -",
         "  import Thing from 'npm library'",
         "",
         "  import OtherThing from '~internal file path",
         "  -",
         "",
         "  We want libraries on top and project imports on the bottom with a space seperating them.",
         "  If you are unsure if there is a component that already exists, check in #frontend-guild. We want to be reusing as much as possible.",
         "*/",
         "import PropTypes from 'prop-types';",
         "",
         "import { View as ${1:viewName} } from '~${2:viewPath}';",
         "",
         "/*",
         "  This is the hook container which wraps a View. The goal here is to compute all the data, use react-query hooks, etc and get all your data and functions",
         "  ready for the view. You can even define styles and such here if needed for branching components (rare but worth mentioning).",
         "",
         "  All computed props should be added to the hookProps object which will just spread them in, overwriting props if keynames overlap.",
         "",
         "  The reason we do the hookprops spread is mostly because destructuring makes it more convenient to add props to an object and spreading it in",
         "  rather than adding props to the component tag.",
         "",
         "  Any questions, feel free to ask #frontend-guild on Slack.",
         "*/",
         "const ${3:hookName} = ({...props}) => {",
         "  const hookProps = {};",
         "",
         "  return (",
         "    <View",
         "      {...props}",
         "      {...hookProps}",
         "    />",
         "  );",
         "};",
         "",
         "/*",
         "  https://github.com/facebook/prop-types#usage",
         "  Poor man's type checking",
         "",
         "  We also have a file at ~Common/const/proptypes.js that is meant to hold complex shapes.",
         "",
         "  If the shape you need to make is too complex or difficult to figure out, you can just do a PropTypes.object in the proptypes file,",
         "  as long as the type has a name with meaning, the linter won't flag it. That file has examples of this already.",
         "",
         "  As for required props, there isn't really a hard and fast rule. It's up to your discretion on how to implement this. I tend to",
         "  favor making more things required than not unless it's actually optional at the hook level.",
         "",
         "  Any questions, feel free to ask #frontend-guild on Slack.",
         "*/",
         "${3:hookName}.propTypes = {};",
         "",
         "${3:hookName}.defaultProps = {};",
         "",
         "/*",
         "  Since the Hook implements the View, we default export the hook since it's the main use case. If you need the View",
         "  this implements, either import it from the same location this file does, or include this hook in the file",
         "  with the view as a 2nd hook that can be exported.",
         "",
         "  Any questions, feel free to ask #frontend-guild on Slack.",
         "*/",
         "export { View };",
         "export default ${3:hookName};"
      ]
   },
   "Hook Container":{
      "description":"Generates a hook container",
      "prefix":"leadr-hookContainer",
      "body":[
         "import PropTypes from 'prop-types';",
         "",
         "import { View } from '~${1:viewPath}';",
         "",
         "const ${2:argName} = ({...props}) => {",
         "  const hookProps = {};",
         "",
         "  return (",
         "    <View",
         "      {...hookProps}",
         "      {...props}",
         "    />",
         "  );",
         "};",
         "",
         "${2:argName}.propTypes = {};",
         "",
         "${2:argName}.defaultProps = {};",
         "",
         "export { View };",
         "export default ${2:argName};"
      ]
   },
   "List w/ Detail View":{
      "description":"Generates a react-query scaffold for lists & detail workflows, includes introductory comments and details",
      "prefix":"leadr-detailHook",
      "body":[
         "import {",
         "  useListItem, useList, useQueryConfig,",
         "} from '~Common/queries';",
         "import { buildFlattener, buildInfiniteFlattener } from '~Common/hooks/utils';",
         "import useDetailWithListItem from '~Common/queries/useDetailWithListItem';",
         "",
         "export const ${1/(.*)/${1:/upcase}/}_STATUS = {",
         "  // DEFAULT: 'DEFAULT',",
         "};",
         "",
         "const infiniteFlatteners = buildInfiniteFlattener(${1/(.*)/${1:/upcase}/}_STATUS);",
         "",
         "const listConfig = {",
         "  buildApi: ({ ${2:currentUserOrgId} }) => ['/organizations/', ${2:currentUserOrgId}, '/${1/(.*)/${1:/downcase}/}s'].join(''),",
         "  buildQueryKey: ({ ${3:currentUserOrgId} }) => [${3:currentUserOrgId}, '${1/(.*)/${1:/downcase}/}s'],",
         "  listFlattener: buildFlattener({}),",
         "  normalizeItemFromServer: (result) => (result),",
         "};",
         "",
         "const useFetchParams = (state) => ({",
         "  state,",
         "});",
         "",
         "const use${1/(.*)/${1:/capitalize}/}s = (status) => {",
         "  const fetchParams = useFetchParams(status);",
         "",
         "  const queryConfig = useQueryConfig({",
         "    ...listConfig,",
         "    fetchParams,",
         "    infiniteFlattener: infiniteFlatteners[status],",
         "  });",
         "",
         "  return useList({",
         "    queryConfig,",
         "  });",
         "};",
         "",
         "const use${1/(.*)/${1:/capitalize}/}ListItem = (id, status) => {",
         "  const fetchParams = useFetchParams(status);",
         "",
         "  const queryConfig = useQueryConfig({",
         "    ...listConfig,",
         "    fetchParams,",
         "    infiniteFlattener: infiniteFlatteners[status],",
         "  });",
         "",
         "  const { item } = useListItem({",
         "    queryConfig,",
         "    id,",
         "  });",
         "",
         "  return item;",
         "};",
         "",
         "const use${1/(.*)/${1:/capitalize}/}Detail = (id, status) => {",
         "  const fetchParams = useFetchParams(status);",
         "",
         "  const queryConfig = useQueryConfig({",
         "    ...listConfig,",
         "    fetchParams,",
         "    infiniteFlattener: infiniteFlatteners[status],",
         "  });",
         "",
         "  return useDetailWithListItem({",
         "    id,",
         "    queryConfig,",
         "  });",
         "};",
         "",
         "export {",
         "  use${1/(.*)/${1:/capitalize}/}s, use${1/(.*)/${1:/capitalize}/}ListItem, use${1/(.*)/${1:/capitalize}/}Detail,",
         "};"
      ]
   },
   "List w/ Detail View - Commented":{
      "description":"Generates a react-query scaffold for lists & detail workflows, includes introductory comments and details",
      "prefix":"leadr-detailHook-commented",
      "body":[
         "/*",
         "  Let's talk imports.",
         "",
         "  For imports, we prefer the following format",
         "",
         "  -",
         "  import Thing from 'npm library'",
         "",
         "  import OtherThing from '~internal file path",
         "  -",
         "",
         "  We want libraries on top and project imports on the bottom with a space seperating them.",
         "  If you are unsure if there is functionality that already exists, check in #frontend-guild. We want to be reusing as much as possible.",
         "*/",
         "import {",
         "  useListItem, useList, useQueryConfig,",
         "} from '~Common/queries';",
         "import { buildFlattener, buildInfiniteFlattener } from '~Common/hooks/utils';",
         "",
         "/*",
         "  If your API has different views that rely on some kind of state, like",
         "    - active vs draft",
         "    - complete vs incomplete",
         "    - requested by you vs requested for you",
         "  then this is where you should make an enum mapping of those states. They live here because they directly affect how your query caches",
         "  and functions, and it also affects how your flattener works.",
         "",
         "  Things other than view states like paging, sorting, searching, etc will be handled in useFetchParams below.",
         "*/",
         "export const ${1/(.*)/${1:/upcase}/}_STATUS = {",
         "  // DEFAULT: 'DEFAULT',",
         "};",
         "",
         "/*",
         "  This returns an object of { status value : memoized function }, with one for each status value listed above. ",
         "",
         "  These will memoize the collapsed list for you so when you do your lookups for each item, you don't have to re-collapse the",
         "  api into a dictionary. ",
         "",
         "  Hooks are instanced, so if you have a list with 200 items, then to render all 200 items you would need to collapse the list 200 times,",
         "  which is sadness. These functions help turn that O(n) operaiton into an O(1). ",
         "",
         "  Most of this is hidden from you and you shouldn't need to care about it, aside from making sure to pass this into your useQueryConfig implementations",
         "  below. We will talk about it when we get to it.",
         "",
         "  If you don't have statuses for an API, it is recommended you pass in { DEFAULT: 'DEFAULT' } and then use that as your 'status' params below so it can",
         "  still be memoized.",
         "*/",
         "const infiniteFlatteners = buildInfiniteFlattener(${1/(.*)/${1:/upcase}/}_STATUS);",
         "",
         "/*",
         "  This is your static useQueryConfig block. This holds all the queryConfig params that don't need re-defined on a per-hook basis. Let's look at each:",
         "  ",
         "    - buildApi: ({ currentUserOrgId, currentUserId, currentUserOrgUserId, ...fetchParams }) => string",
         "      This is a function that is passed user-context, as well as whatever useFetchParams returns, and is meant to build a base url.",
         "      Lists use this directly, and detail calls append a '/:id' at the end of this.",
         "      We might need to expand this a bit more to take in a context if we have some inconsistent APIs that arent as neat as this.",
         "",
         "    - buildQueryKey: ({ currentUserOrgId, currentUserId, currentUserOrgUserId, ...fetchParams }) => [string]",
         "      This is a function that is passed user-context, as well as whatever useFetchParams returns, and is meant to build a base queryKey.",
         "      This queryKey will then have other things appended to it depending on the context. ",
         "        - Lists will append 'list' and the entire object from useFetchParams",
         "        - Detail calls will append the actual id",
         "      This will keep caches unique and create a consistent scheme for queryKeys.",
         "",
         "    - listFlattener: buildFlattener({ listSelector, idName }) => func",
         "      This is a function that will flatten the api response into a list of ids and a dictionary lookup by id. This is needed for all our generic workflows.",
         "      For most of our new code, you shouldn't need to pass it any parameters, but for older apis that arent as consistent, the args work as follows:",
         "        - listSelector",
         "        This is a function that give you the response, and you return the array that holds the list. By default, it expects the list to be in object.response.items.",
         "",
         "        - idName",
         "        This is the name of the id on each item. It defaults to 'id', and this is usually correct, but sometimes you get an API that explicitly names it's id.",
         "",
         "    - normalizeItemFromServer (item) => (normalizedItem) (optional)",
         "      Similarly to the listFlattener, this is a utility method that is ran for every item that the listFlattener processes. This is a great place to normalize data,",
         "      set defaults, etc. If you don't need to normalize the data, you can just not include this. This is completely optional.",
         "      Note that this is not a hook, and you cannot normalize data with hooks. If you need hook data, its recommended to fetch it where the data is used with a uid or something,",
         "      rather than injecting all of that here.",
         "*/",
         "const listConfig = {",
         "  buildApi: ({ ${2:currentUserOrgId} }) => ['/organizations/', ${2:currentUserOrgId}, '/${1/(.*)/${1:/downcase}/}s'].join(''),",
         "  buildQueryKey: ({ ${3:currentUserOrgId} }) => [${3:currentUserOrgId}, '${1/(.*)/${1:/downcase}/}s'],",
         "  listFlattener: buildFlattener({}),",
         "  normalizeItemFromServer: (result) => (result),",
         "};",
         "",
         "/*",
         "  This is a hook that composes everything the list API needs to fetch. Paging is handled automatically for you, you just need to return an object that has",
         "  all the sort/search/filter type params.",
         "",
         "  The keynames of this object will be what the queryString key names passed to the API will be called.",
         "",
         "  These being undefined or empty strings will filter them out. This uses buildQueryString under the hood, which can be found in ~Common/utils",
         "*/",
         "const useFetchParams = (status) => ({",
         "  status,",
         "});",
         "",
         "/*",
         "  https://leadrhq.atlassian.net/wiki/spaces/PROD/pages/1668907027/React+Query+Patterns#List-of-Items",
         "",
         "  This is your list, and should be used in confjunction with something like the InfiniteList component.",
         "*/",
         "const use${1/(.*)/${1:/capitalize}/}s = (status) => {",
         "  /*",
         "    Call your useFetchParams hook here, passing in a status/state if it's relevant. This is used in the query config object.",
         "  */",
         "  const fetchParams = useFetchParams(status);",
         "",
         "  /*",
         "    Spread our static config items into this, and then pass in the hook context items like fetchParams and the infinite flattener.",
         "",
         "    This will pass in one of the memoized functions mentioned above, based on status. If you do not have status, this is where you would pass 'DEFAULT'",
         "  */",
         "  const queryConfig = useQueryConfig({",
         "    ...listConfig,",
         "    fetchParams,",
         "    infiniteFlattener: infiniteFlatteners[status],",
         "  });",
         "",
         "  /*",
         "    This returns an object that has all of the following:",
         "    https://react-query.tanstack.com/reference/useQuery",
         "    https://react-query.tanstack.com/reference/useInfiniteQuery",
         "",
         "    In addition to the above, these also have the following properties we inject:",
         "      - listData: An id:object dictionary lookup map",
         "      - lists: An array of ids that can be mapped over. Item 0 on the client is equal to the first item returned by the server for your given params.",
         "      - initialPageItemCount: A number representing the total items available to page through.",
         "",
         "    listData and lists are fully memoized, so you can use rely on these as dependencies for useCallback/useMemo.",
         "  */",
         "  return useList({",
         "    queryConfig,",
         "  });",
         "};",
         "",
         "/*",
         "  https://leadrhq.atlassian.net/wiki/spaces/PROD/pages/1668907027/React+Query+Patterns#List-of-Items",
         "",
         "  This is your hook that deals with a item in a list. The difference between a ListItem and a DetailItem is that a ListItem",
         "  references the List, which is abbreviated data, whereas the DetailItem references the complete item.",
         "",
         "  This will use detail data if it's available and is more up to date than the list data.",
         "*/",
         "const use${1/(.*)/${1:/capitalize}/}ListItem = (id, status) => {",
         "  /*",
         "    Call your useFetchParams hook here, passing in a status/state if it's relevant. This is used in the query config object.",
         "  */",
         "  const fetchParams = useFetchParams(status);",
         "",
         "  /*",
         "    Spread our static config items into this, and then pass in the hook context items like fetchParams and the infinite flattener.",
         "",
         "    This will pass in one of the memoized functions mentioned above, based on status. If you do not have status, this is where you would pass 'DEFAULT'",
         "  */",
         "  const queryConfig = useQueryConfig({",
         "    ...listConfig,",
         "    fetchParams,",
         "    infiniteFlattener: infiniteFlatteners[status],",
         "  });",
         "",
         "  /*",
         "    This returns an object that has all of the following:",
         "    https://react-query.tanstack.com/reference/useQuery",
         "    https://react-query.tanstack.com/reference/useInfiniteQuery",
         "",
         "    In addition to the above, these also have the following properties we inject:",
         "      - item: The individual item that is looked up by id",
         "",
         "    item is fully memoized, so you can use this as dependencies for useCallback/useMemo.",
         "  */",
         "  return useListItem({",
         "    queryConfig,",
         "    id,",
         "  });",
         "};",
         "",
         "/*",
         "  https://leadrhq.atlassian.net/wiki/spaces/PROD/pages/1668907027/React+Query+Patterns#List-of-Items",
         "",
         "  This hook deals with your detail views, typically a drawer. This is your complete object, and may not always be used as not all of ",
         "  our APIs support a detail view.",
         "",
         "  Since this uses useDetailWithListItem, it will fall back to listItem data is the detail doesn't exist, or if the list data is more recent",
         "  than the detail data. If the list data is more recent, this will trigger a queryClient invalidation so the detail will catch up.",
         "*/",
         "const use${1/(.*)/${1:/capitalize}/}Detail = (id, status) => {",
         "  /*",
         "    Call your useFetchParams hook here, passing in a status/state if it's relevant. This is used in the query config object.",
         "  */",
         "  const fetchParams = useFetchParams(status);",
         "",
         "  /*",
         "    Spread our static config items into this, and then pass in the hook context items like fetchParams and the infinite flattener.",
         "",
         "    This will pass in one of the memoized functions mentioned above, based on status. If you do not have status, this is where you would pass 'DEFAULT'",
         "  */",
         "  const queryConfig = useQueryConfig({",
         "    ...listConfig,",
         "    fetchParams,",
         "    infiniteFlattener: infiniteFlatteners[status],",
         "  });",
         "",
         "  /*",
         "    This returns an object that has all of the following:",
         "    https://react-query.tanstack.com/reference/useQuery",
         "    https://react-query.tanstack.com/reference/useInfiniteQuery",
         "",
         "    In addition to the above, these also have the following properties we inject:",
         "      - item: The individual item that is looked up by id",
         "",
         "    item is fully memoized, so you can use this as dependencies for useCallback/useMemo.",
         "  */",
         "  return useDetailWithListItem({",
         "    id,",
         "    queryConfig,",
         "  });",
         "};",
         "",
         "export {",
         "  use${1/(.*)/${1:/capitalize}/}s, use${1/(.*)/${1:/capitalize}/}ListItem, use${1/(.*)/${1:/capitalize}/}Detail,",
         "};"
      ]
   },
   "List w/o Detail View - Commented":{
      "description":"Generates a react-query scaffold for lists without detail workflows, includes introductory comments and details",
      "prefix":"leadr-listHook-commented",
      "body":[
         "/*",
         "  Let's talk imports.",
         "",
         "  For imports, we prefer the following format",
         "",
         "  -",
         "  import Thing from 'npm library'",
         "",
         "  import OtherThing from '~internal file path",
         "  -",
         "",
         "  We want libraries on top and project imports on the bottom with a space seperating them.",
         "  If you are unsure if there is functionality that already exists, check in #frontend-guild. We want to be reusing as much as possible.",
         "*/",
         "import {",
         "  useListItem, useList, useQueryConfig,",
         "} from '~Common/queries';",
         "import { buildFlattener, buildInfiniteFlattener } from '~Common/hooks/utils';",
         "",
         "/*",
         "  If your API has different views that rely on some kind of state, like",
         "    - active vs draft",
         "    - complete vs incomplete",
         "    - requested by you vs requested for you",
         "  then this is where you should make an enum mapping of those states. They live here because they directly affect how your query caches",
         "  and functions, and it also affects how your flattener works.",
         "",
         "  Things other than view states like paging, sorting, searching, etc will be handled in useFetchParams below.",
         "*/",
         "export const ${1/(.*)/${1:/upcase}/}_STATUS = {",
         "  // DEFAULT: 'DEFAULT',",
         "};",
         "",
         "/*",
         "  This returns an object of { status value : memoized function }, with one for each status value listed above. ",
         "",
         "  These will memoize the collapsed list for you so when you do your lookups for each item, you don't have to re-collapse the",
         "  api into a dictionary. ",
         "",
         "  Hooks are instanced, so if you have a list with 200 items, then to render all 200 items you would need to collapse the list 200 times,",
         "  which is sadness. These functions help turn that O(n) operaiton into an O(1). ",
         "",
         "  Most of this is hidden from you and you shouldn't need to care about it, aside from making sure to pass this into your useQueryConfig implementations",
         "  below. We will talk about it when we get to it.",
         "",
         "  If you don't have statuses for an API, it is recommended you pass in { DEFAULT: 'DEFAULT' } and then use that as your 'status' params below so it can",
         "  still be memoized.",
         "*/",
         "const infiniteFlatteners = buildInfiniteFlattener(${1/(.*)/${1:/upcase}/}_STATUS);",
         "",
         "/*",
         "  This is your static useQueryConfig block. This holds all the queryConfig params that don't need re-defined on a per-hook basis. Let's look at each:",
         "  ",
         "    - buildApi: ({ currentUserOrgId, currentUserId, currentUserOrgUserId, ...fetchParams }) => string",
         "      This is a function that is passed user-context, as well as whatever useFetchParams returns, and is meant to build a base url.",
         "      Lists use this directly, and detail calls append a '/:id' at the end of this.",
         "      We might need to expand this a bit more to take in a context if we have some inconsistent APIs that arent as neat as this.",
         "",
         "    - buildQueryKey: ({ currentUserOrgId, currentUserId, currentUserOrgUserId, ...fetchParams }) => [string]",
         "      This is a function that is passed user-context, as well as whatever useFetchParams returns, and is meant to build a base queryKey.",
         "      This queryKey will then have other things appended to it depending on the context. ",
         "        - Lists will append 'list' and the entire object from useFetchParams",
         "        - Detail calls will append the actual id",
         "      This will keep caches unique and create a consistent scheme for queryKeys.",
         "",
         "    - listFlattener: buildFlattener({ listSelector, idName }) => func",
         "      This is a function that will flatten the api response into a list of ids and a dictionary lookup by id. This is needed for all our generic workflows.",
         "      For most of our new code, you shouldn't need to pass it any parameters, but for older apis that arent as consistent, the args work as follows:",
         "        - listSelector",
         "        This is a function that give you the response, and you return the array that holds the list. By default, it expects the list to be in object.response.items.",
         "",
         "        - idName",
         "        This is the name of the id on each item. It defaults to 'id', and this is usually correct, but sometimes you get an API that explicitly names it's id.",
         "",
         "    - normalizeItemFromServer (item) => (normalizedItem) (optional)",
         "      Similarly to the listFlattener, this is a utility method that is ran for every item that the listFlattener processes. This is a great place to normalize data,",
         "      set defaults, etc. If you don't need to normalize the data, you can just not include this. This is completely optional.",
         "      Note that this is not a hook, and you cannot normalize data with hooks. If you need hook data, its recommended to fetch it where the data is used with a uid or something,",
         "      rather than injecting all of that here.",
         "*/",
         "const listConfig = {",
         "  buildApi: ({ ${2:currentUserOrgId} }) => ['/organizations/', ${2:currentUserOrgId}, '/${1/(.*)/${1:/downcase}/}s'].join(''),",
         "  buildQueryKey: ({ ${3:currentUserOrgId} }) => [${3:currentUserOrgId}, '${1/(.*)/${1:/downcase}/}s'],",
         "  listFlattener: buildFlattener({}),",
         "  normalizeItemFromServer: (result) => (result),",
         "};",
         "",
         "/*",
         "  This is a hook that composes everything the list API needs to fetch. Paging is handled automatically for you, you just need to return an object that has",
         "  all the sort/search/filter type params.",
         "",
         "  The keynames of this object will be what the queryString key names passed to the API will be called.",
         "",
         "  These being undefined or empty strings will filter them out. This uses buildQueryString under the hood, which can be found in ~Common/utils",
         "*/",
         "const useFetchParams = (status) => ({",
         "  status,",
         "});",
         "",
         "/*",
         "  https://leadrhq.atlassian.net/wiki/spaces/PROD/pages/1668907027/React+Query+Patterns#List-of-Items",
         "",
         "  This is your list, and should be used in confjunction with something like the InfiniteList component.",
         "*/",
         "const use${1/(.*)/${1:/capitalize}/}s = (status) => {",
         "  /*",
         "    Call your useFetchParams hook here, passing in a status/state if it's relevant. This is used in the query config object.",
         "  */",
         "  const fetchParams = useFetchParams(status);",
         "",
         "  /*",
         "    Spread our static config items into this, and then pass in the hook context items like fetchParams and the infinite flattener.",
         "",
         "    This will pass in one of the memoized functions mentioned above, based on status. If you do not have status, this is where you would pass 'DEFAULT'",
         "  */",
         "  const queryConfig = useQueryConfig({",
         "    ...listConfig,",
         "    fetchParams,",
         "    infiniteFlattener: infiniteFlatteners[status],",
         "  });",
         "",
         "  /*",
         "    This returns an object that has all of the following:",
         "    https://react-query.tanstack.com/reference/useQuery",
         "    https://react-query.tanstack.com/reference/useInfiniteQuery",
         "",
         "    In addition to the above, these also have the following properties we inject:",
         "      - listData: An id:object dictionary lookup map",
         "      - lists: An array of ids that can be mapped over. Item 0 on the client is equal to the first item returned by the server for your given params.",
         "      - initialPageItemCount: A number representing the total items available to page through.",
         "",
         "    listData and lists are fully memoized, so you can use rely on these as dependencies for useCallback/useMemo.",
         "  */",
         "  return useList({",
         "    queryConfig,",
         "  });",
         "};",
         "",
         "/*",
         "  https://leadrhq.atlassian.net/wiki/spaces/PROD/pages/1668907027/React+Query+Patterns#List-of-Items",
         "",
         "  This is your hook that deals with a item in a list. The difference between a ListItem and a DetailItem is that a ListItem",
         "  references the List, which is abbreviated data, whereas the DetailItem references the complete item.",
         "",
         "  This will use detail data if it's available and is more up to date than the list data.",
         "*/",
         "const use${1/(.*)/${1:/capitalize}/}ListItem = (id, status) => {",
         "  /*",
         "    Call your useFetchParams hook here, passing in a status/state if it's relevant. This is used in the query config object.",
         "  */",
         "  const fetchParams = useFetchParams(status);",
         "",
         "  /*",
         "    Spread our static config items into this, and then pass in the hook context items like fetchParams and the infinite flattener.",
         "",
         "    This will pass in one of the memoized functions mentioned above, based on status. If you do not have status, this is where you would pass 'DEFAULT'",
         "  */",
         "  const queryConfig = useQueryConfig({",
         "    ...listConfig,",
         "    fetchParams,",
         "    infiniteFlattener: infiniteFlatteners[status],",
         "  });",
         "",
         "  /*",
         "    This returns an object that has all of the following:",
         "    https://react-query.tanstack.com/reference/useQuery",
         "    https://react-query.tanstack.com/reference/useInfiniteQuery",
         "",
         "    In addition to the above, these also have the following properties we inject:",
         "      - item: The individual item that is looked up by id",
         "",
         "    item is fully memoized, so you can use this as dependencies for useCallback/useMemo.",
         "  */",
         "  return useListItem({",
         "    queryConfig,",
         "    id,",
         "  });",
         "};",
         "",
         "export {",
         "  use${1/(.*)/${1:/capitalize}/}s, use${1/(.*)/${1:/capitalize}/}ListItem,",
         "};"
      ]
   },
   "Drawer Component - Commented":{
      "description":"Generates a drawer component and hook container with introductory documentation to best practices",
      "prefix":"leadr-drawerComponent-commented",
      "body":[
         "/*",
         "  Let's talk imports.",
         "",
         "  For imports, we prefer the following format",
         "",
         "  -",
         "  import Thing from 'npm library'",
         "",
         "  import OtherThing from '~internal file path",
         "  -",
         "",
         "  We want libraries on top and project imports on the bottom with a space seperating them.",
         "  If you are unsure if there is a component that already exists, check in #frontend-guild. We want to be reusing as much as possible.",
         "*/",
         "",
         "import { css } from '@emotion/react';",
         "import { DRAWER_WIDTHS, DrawerProps } from '~Common/const/drawers';",
         "",
         "import { palette } from '~Common/styles/colors';",
         "import { registerDrawer, templateType } from '~Deprecated/ui/views/DrawerManager';",
         "",
         "/*",
         "  We use emotion to style our components. You can use the following resources to learn more about emotion below:",
         "  https://emotion.sh/docs/introduction",
         "  https://emotion.sh/docs/css-prop",
         "",
         "  The most important thing to understand with emotion is that the css prop is transformed into a classname.",
         "  If you don't either spread props or pass the classname down, then it will not propagate for custom components.",
         "",
         "  We have a lot of common data like colors, animations, fonts, etc inside of ~Common/styles so check there if you need anything.",
         "",
         "  Any questions, feel free to ask #frontend-guild on Slack.",
         "*/",
         "const styles = {",
         "  ${1/(.*)/${1:/camelcase}/}: css({",
         "    backgroundColor: palette.neutrals.gray500,",
         "  }),",
         "};",
         "",
         "/*",
         "  Drawers get this options block that is used by other components that need to push this drawer. It's just a name and a width. To use this",
         "  to interact with a drawer, you will want to use pushDrawer, popDrawer, or popAfter. Search the app for examples of each if needed.",
         "",
         "  Any questions, feel free to ask #frontend-guild on Slack.",
         "*/",
         "/*",
         "  All you have to do is type the name of the drawer in Proper case. Example: CreateMeetingDrawer",
         "  Then press Tab on your keyboard and the snippet will fill in all the variables with the right casing",
         "*/",
         "export const ${1/(.*)/${1:/camelcase}/}Template = {",
         "  name: '${1/([A-Z][a-z]+$)|((^|[A-Z])[a-z]+)/${1:/upcase}${2:/upcase}${2:+_}/gm}',",
         "  type: templateType.PRIMARY,",
         "  width: DRAWER_WIDTHS.PRIMARY,",
         "};",
         "",
         "/*",
         "  The point of seperating these View components from the Hooks (seen below) is to create a kind of model-view pattern.",
         "  The goal is that props should contain everything this component needs to render. It shouldn't pull in anything",
         "  outside of major library imports unless it's from props.",
         "",
         "  It also should not compute anything, instantiate anything, etc. It should only pull from props and implement.",
         "",
         "  This is known as a pure component. The idea here is that a pure component is easier to test and more reusable.",
         "  This View will be exported from this file, and another hook can be made that reuses this View if the opportunity arises.",
         "",
         "  Any questions, feel free to ask #frontend-guild on Slack.",
         "*/",
         "",
         "/*",
         "  We use Typescript inside of our components. You can use the following link to learn more about Typescript:",
         "  https://www.typescriptlang.org/docs/",
         "*/",
         "interface ViewProps {",
         "",
         "}",
         "",
         "const View = ({ ...props }: ViewProps): JSX.Element => (",
         "  <div",
         "    css={styles.${1/(.*)/${1:/camelcase}/}}",
         "    {...props}",
         "  >",
         "    The View!",
         "  </div>",
         ");",
         "",
         "/*",
         "  This is the hook container which wraps the View. The goal here is to compute all the data, use react-query hooks, etc and get all your data and functions",
         "  ready for the view. You can even define styles and such here if needed for branching components (rare but worth mentioning).",
         "",
         "  All computed props should be added to the hookProps object which will just spread them in, overwriting props if keynames overlap.",
         "",
         "  The reason we do the hookprops spread is mostly because destructuring makes it more convenient to add props to an object and spreading it in",
         "  rather than adding props to the component tag.",
         "",
         "  Any questions, feel free to ask #frontend-guild on Slack.",
         "*/",
         "",
         "/*",
         "  We use Typescript inside of our components. You can use the following link to learn more about Typescript:",
         "  https://www.typescriptlang.org/docs/",
         "*/",
         "interface ${1:argName}Props extends DrawerProps<unknown> {",
         "",
         "}",
         "",
         "const ${1:argName} = ({ ...props }: ${1:argName}Props): JSX.Element => {",
         "  const hookProps = {};",
         "",
         "  return (",
         "    <View",
         "      {...hookProps}",
         "      {...props}",
         "    />",
         "  );",
         "};",
         "",
         "/*",
         "  You need to inform the drawer manager of the name and it's associated component so it knows how to handle it.",
         "*/",
         "registerDrawer({",
         "  templateName: ${1/(.*)/${1:/camelcase}/}Template.name,",
         "  component: ${1:argName},",
         "});",
         "",
         "/*",
         "  We export both the View and the Hook. Since the Hook implements the View, we default export the hook and specificaly export the View for things",
         "  like tests and code reuse in the future if it's needed. For practical purposes, you will almost never import the View.",
         "",
         "  Any questions, feel free to ask #frontend-guild on Slack.",
         "*/",
         "export { View };",
         "export default ${1:argName};",
         ""
      ]
   },
   "List w/o Detail View":{
      "description":"Generates a react-query scaffold for lists without detail workflows",
      "prefix":"leadr-listHook",
      "body":[
         "import {",
         "  useListItem, useList, useQueryConfig,",
         "} from '~Common/queries';",
         "import { buildFlattener, buildInfiniteFlattener } from '~Common/hooks/utils';",
         "",
         "export const ${1/(.*)/${1:/upcase}/}_STATUS = {",
         "  // DEFAULT: 'DEFAULT',",
         "};",
         "",
         "const infiniteFlatteners = buildInfiniteFlattener(${1/(.*)/${1:/upcase}/}_STATUS);",
         "",
         "const listConfig = {",
         "  buildApi: ({ ${2:currentUserOrgId} }) => ['/organizations/', ${2:currentUserOrgId}, '/${1/(.*)/${1:/downcase}/}s'].join(''),",
         "  buildQueryKey: ({ ${3:currentUserOrgId} }) => [${3:currentUserOrgId}, '${1/(.*)/${1:/downcase}/}s'],",
         "  listFlattener: buildFlattener({}),",
         "  normalizeItemFromServer: (result) => (result),",
         "};",
         "",
         "const useFetchParams = (state) => ({",
         "  state,",
         "});",
         "",
         "const use${1/(.*)/${1:/capitalize}/}s = (status) => {",
         "  const fetchParams = useFetchParams(status);",
         "",
         "  const queryConfig = useQueryConfig({",
         "    ...listConfig,",
         "    fetchParams,",
         "    infiniteFlattener: infiniteFlatteners[status],",
         "  });",
         "",
         "  return useList({",
         "    queryConfig,",
         "  });",
         "};",
         "",
         "const use${1/(.*)/${1:/capitalize}/}ListItem = (id, status) => {",
         "  const fetchParams = useFetchParams(status);",
         "",
         "  const queryConfig = useQueryConfig({",
         "    ...listConfig,",
         "    fetchParams,",
         "    infiniteFlattener: infiniteFlatteners[status],",
         "  });",
         "",
         "  const { item } = useListItem({",
         "    queryConfig,",
         "    id,",
         "  });",
         "",
         "  return item;",
         "};",
         "",
         "export {",
         "  use${1/(.*)/${1:/capitalize}/}s, use${1/(.*)/${1:/capitalize}/}ListItem,",
         "};"
      ]
   },
   "Mutation":{
      "description":"Generates a react-query hook for a POST/PATCH/DELETE request",
      "prefix":"leadr-mutation",
      "body":[
         "import { useMutation, UseMutationOptions, UseMutationResult } from '@tanstack/react-query';",
         "import { getOrganizationId } from '~Common/utils/localStorage';",
         "import { ${1|post,patch,delete|}Api, HttpCallReturn } from '~Deprecated/services/HttpService';",
         "",
         "interface ${1/(.*)/${1:/pascalcase}/}${2:Thing}Params {",
         "",
         "}",
         "",
         "interface ${3:ReturnInterface} {",
         "",
         "}",
         "",
         "const ${1/(.*)/${1:/downcase}/}${2/(.*)/${1:/pascalcase}/} = async ({ }: ${2/(.*)/${1:/pascalcase}/}Params): Promise<HttpCallReturn<${3/(.*)/${1:/pascalcase}/}>> => {",
         "  const organizationId = getOrganizationId() ?? '';",
         "  const url = `/organizations/\\${organizationId}/theRestGoesHere`; // <-- Fill this in",
         "",
         "  return ${1/(.*)/${1:/downcase}/}Api<${3}>(url, {});",
         "};",
         "",
         "interface Use${1/(.*)/${1:/pascalcase}/}${2/(.*)/${1:/pascalcase}/}Params extends Omit<",
         "  UseMutationOptions<HttpCallReturn<${3}>, Error, ${1/(.*)/${1:/pascalcase}/}${2/(.*)/${1:/pascalcase}/}Params>, 'mutationFn'",
         "> {",
         "",
         "}",
         "",
         "export const use${1/(.*)/${1:/pascalcase}/}${2/(.*)/${1:/pascalcase}/} = ({",
         "  ...options",
         "}: Use${1/(.*)/${1:/pascalcase}/}${2/(.*)/${1:/pascalcase}/}Params): UseMutationResult<HttpCallReturn<${3}>, Error, ${1/(.*)/${1:/pascalcase}/}${2/(.*)/${1:/pascalcase}/}Params> => {",
         "",
         "  return useMutation({",
         "    mutationFn: ${1/(.*)/${1:/downcase}/}${2/(.*)/${1:/pascalcase}/},",
         "    onMutate: () => {},",
         "    onSuccess: () => {},",
         "    onError: () => {},",
         "    ...options,",
         "  });",
         "};",
         ""
      ]
   },
   "PropType Snippet":{
      "description":"A quick proptype snippet for the lazy",
      "prefix":"leadr-proptypes",
      "body":[
         "import PropTypes from 'prop-types';",
         "",
         "${1:componentName}.propTypes = {",
         "  ${2:propName}: PropTypes.$3",
         "};",
         "",
         "${1:componentName}.defaultProps = {};"
      ]
   },
   "Query":{
      "description":"Generates a react-query hook for a GET request",
      "prefix":"leadr-query",
      "body":[
         "import { useQuery, UseQueryOptions, UseQueryResult } from '@tanstack/react-query';",
         "import { getOrganizationId } from '~Common/utils/localStorage';",
         "import { getApi, HttpCallReturn } from '~Deprecated/services/HttpService';",
         "",
         "interface Get${1:Item}Params {",
         "  organizationId: string,",
         "}",
         "",
         "interface ${2/(.*)/${1:/pascalcase}/} {",
         "",
         "}",
         "",
         "const get${1/(.*)/${1:/pascalcase}/} = async ({ organizationId }: Get${1}Params): Promise<HttpCallReturn<${2:ReturnInterface}>> => {",
         "  const url = `/organizations/\\${organizationId}/theRestGoesHere`; // <-- Fill this in",
         "",
         "  return getApi<${2/(.*)/${1:/pascalcase}/}>(url);",
         "};",
         "",
         "interface UseGet${1/(.*)/${1:/pascalcase}/}Params<T> extends Omit<UseQueryOptions<HttpCallReturn<${2/(.*)/${1:/pascalcase}/}>, Error, T>, 'queryKey' | 'queryFn'> {",
         "",
         "}",
         "",
         "export const useGet${1/(.*)/${1:/pascalcase}/} = <T = HttpCallReturn<${2/(.*)/${1:/pascalcase}/}>>({",
         "  ...options",
         "}: UseGet${1/(.*)/${1:/pascalcase}/}Params<T>): UseQueryResult<T, Error> => {",
         "  const organizationId = getOrganizationId() ?? '';",
         "",
         "  return useQuery({",
         "    queryKey: ['queryKeyHere'], // <-- Fill this in",
         "    queryFn: () => get${1/(.*)/${1:/pascalcase}/}({ organizationId }),",
         "    ...options,",
         "  });",
         "};",
         ""
      ]
   }
}
